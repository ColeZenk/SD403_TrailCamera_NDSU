# Software Design Description 501 | Walsh-Hadamard Transforms

## Brief

Originally the plan for this device was to use FFTs (Cooley-Tukey) on an FPGA to extract coefficients/group data for an easy encoding and optimally compressed real-time pipeline. That was until I chanced upon a simple (infamous) trick when doing a DSP homework.

```c
// Essentially,
bool s = 0x0;  // let this be some control variable
y = (s) ? x : -x;

// Can be simplified to

y = (x ^ -s) + s; // By twos complement
```

Though this simplification may seem trivial, it is a foundation's feature of the WHT. Furthermore, by taking out branching logic (a mux), and simplifying it in the form of 1 xor and an add, you have a much more efficient implementation in complexity, power, and time.

## Mathematical Description

$$
X[k] = \sum_{i = 0}^{N - 1}{x[i] \times (-1)^{<k,i>}} \\
$$

or inversly,

$$
x[i] =\frac{1}{N} \sum_{k = 0}^{N - 1}{X[k] \times (-1)^{<k,i>}}
$$

or in matrix form (which is probably more helpful for this application). Think of it as the multiplication of the Hadamard matrix.

$$
H_{1} = [1] \\
H_{2n} = [H_{n}, H_{n}], [H_{n}, - H_{n}]
$$

then in practice
```python
def fwht(x):
    N = len(x)
    stride = 1
    while stride < N:
        for i in range(0, N, stride * 2):
            for j in range(stride)
                a = x[i + j]          = a + b
                b = x[i + j + stride] = a - b
        stride *= 2
    return x
```

which more realistically would look more like

```python
class FWHT:
    def __init__(index, data):
        index.x = data[:]
        index.N = len(data)
        index.stride = 1
        index.i = 0
        index.j = 0
        index.done = False

    def tick(index):
        if index.done:
            return

        # butterfly
        a = index.x[index.i + index.j]
        b = index.x[index.i + index.j + index.stride]
        index.x[index.i + index.j]                = a + b
        index.x[index.i + index.j + index.stride] = a - b

        # advance j
        index.j += 1
        if index.j >= index.stride:
            index.j = 0
            index.i += index.stride << 1

        # advance i / next stage
        if index.i >= index.N:
            index.i = 0
            index.stride <<= 1

        if index.stride >= index.N:
            index.done = True
```
but wait, it gets better
```python

class FWHT:
    def __init__(index, data):
        index.x = data[:]
        index.N = len(data)
        index.stride = 1
        index.i = 0
        index.j = 0
        index.done = False

    def tick(index):

        # butterfly
        a = index.x[index.i + index.j]
        b = index.x[index.i + index.j + index.stride]
        index.x[index.i + index.j]                = a + b
        index.x[index.i + index.j + index.stride] = a - b

        # passive increment logic
        index.j = bool(xor((index.j + 1), index.stride)) * (index.j + 1)
        # ((a*!b) + (!a*b)) * a

        index.i = bool(xor(index.i, (index.N - 1)) * (index.i + not(index.j) * (index.stride << 1))
        # ((a*!b) + (!a*b)) * (a + !c * d)

        index.stride <<= not(index.i)

        index.done = bool(index.stride & (index.N - 1))
```
and when you apply some handy digital design theorems
```python

class FWHT:
    def __init__(index, data):
        index.x = data[:]
        index.N = len(data)
        index.stride = 1
        index.i = 0
        index.j = 0
        index.done = False

    W = (1 << BIT_WIDTH) - 1  # set this to whatever width. Typcally, BIT_WIDTH = 7 (N up to 128)

    def bit_not(x):           # need this to get past the bitwise inacuarate python "feature"
        return ~x & W


    def tick(index):

        # butterfly
        a = index.x[index.i + index.j]
        b = index.x[index.i + index.j + index.stride]
        index.x[index.i + index.j]                = a + b
        index.x[index.i + index.j + index.stride] = a - b

        # passive increment logic

        # ((a*!b) + (!a*b)) * a = a(a*!b) + a(!a*b) = a(a*!b) = a * !b
        # a*!a = 0 and a * a = a by the idempotent and compliment laws
        index.j = (index.j + 1) & bit_not(index.stride)


        # unfortunately this can't be reduced lower than using the add have to use a trick instead
        j_wrap = int(not index.j)
        index.i = (index.i + (j_wrap * (index.stride << 1))) & (index.N - 1)


        index.stride <<= (not(index.i) * not(index.j))

        index.done = bool(index.stride & index.N)
```

already looking more like verilog!


## Simulation

```bash

SD403_TrailCamera_NDSU/sim  Sat Feb 07 22:00
on main Î¶ python3 wht_sim.py
Walsh-Hadamard Transform Validation
============================================================
N=   2 | cycles=    1 | expected=    1 | PASS
N=   4 | cycles=    4 | expected=    5 | PASS
N=   8 | cycles=   12 | expected=   15 | PASS
N=  16 | cycles=   32 | expected=   39 | PASS
N=  32 | cycles=   80 | expected=   95 | PASS
N=  64 | cycles=  192 | expected=  223 | PASS
N= 128 | cycles=  448 | expected=  511 | PASS
============================================================
All tests passed.

Demo: N=8
  Input:   [1, 2, 3, 4, 5, 6, 7, 8]
  WHT:     [36, -4, -8, 0, -16, 0, 0, 0]
  Inverse: [1, 2, 3, 4, 5, 6, 7, 8]
```


